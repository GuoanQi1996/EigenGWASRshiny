---
title: "EigenGWAS Report"
author: "`r Sys.time()`"
#date: "`r Sys.time()`"
output:
 html_document:
    theme: united
    highlight: tango
    code_folding: hide
params:
  froot: arab
  uploadfile: arab
  proportion: 0.2
  espace: 2
  sc: 1
  pcut: 0.05
  height: 480
  width: 480
  nn: 1
  mm: 1
  ne: 1
  me: 1
  GC: NULL
  offDiag: NULL
  Diag: NULL
  hitDT: NULL
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align = 'center')
```

```{r, plotFunc,echo=FALSE}
# Prepare the compact summary of p-values for QQ-plot
qqPlotCache = function(pvalues, ntests = NULL, ismlog10 = FALSE){
  if(is.null(ntests))
    ntests = length(pvalues);
  
  if(ismlog10) {
    ypvs = pvalues;
  } else {
    ypvs = -log10(pvalues);
  }
  xpvs = -log10(seq_along(ypvs) / (ntests+1));
  
  if(is.unsorted(-ypvs))
    ypvs = sort.int(ypvs, decreasing = TRUE);
  
  if(length(ypvs)*2 > ntests) {
    lambda =
      qchisq(p = 0.1^ypvs[ntests/2], df = 1, lower.tail = FALSE) / 
      qchisq(p = 0.5, df = 1, lower.tail = FALSE);
  } else {
    lambda = NULL;
  }
  
  if(length(ypvs) > 1000) {
    # need to filter a bit, make the plotting faster
    levels = as.integer( (xpvs - xpvs[1])/(tail(xpvs,1) - xpvs[1]) * 2000);
    keep = c(TRUE, diff(levels)!=0);
    levels = as.integer( (ypvs - ypvs[1])/(tail(ypvs,1) - ypvs[1]) * 2000);
    keep = keep | c(TRUE, diff(levels)!=0);
    keep = which(keep);
    ypvs = ypvs[keep];
    xpvs = xpvs[keep];
  } else {
    keep = seq_along(ypvs)
  }
  
  qq = list(
    xpvs = xpvs, # p-values expected under null
    ypvs = ypvs, # observer p-values
    keep = keep, # indices of the preserved p-values
    ntests = ntests, # Number of tests
    lambda = lambda  # Estimate of inflation factor lambda
  );
  class(qq) = "qqPlotInfo";
  return(qq);
}

# Create QQ-plot from p-values or prepared summary
qqPlotQ = function(
  x, 
  ntests = NULL, 
  ismlog10 = FALSE, 
  ci.level = 0.05, 
  ylim = NULL, 
  newplot = TRUE, 
  col = "grey", 
  cex = 0.5, 
  yaxmax = NULL, 
  lwd = 3, 
  col.band = "red",
  makelegend = TRUE,
  title = "",
  xlab = expression(
    paste("\u2013", " log"[10]*"(", italic("P"), ") expected")),
  ylab = expression(
    paste("\u2013", " log"[10]*"(", italic("P"), "), observed"))
){
  
  # Get compact summary of p-values for QQ-plot
  if( methods::is(x, "qqPlotInfo") ){
    qq = x;
  } else {
    qq = qqPlotPrepare(pvalues = x, ntests = ntests, ismlog10 = ismlog10);
  }
  
  # Axis ranges
  mx = head(qq$xpvs,1) * 1.05;
  if( is.null(ylim) ) {
    my = max(mx, head(qq$ypvs,1) * 1.05) ;
    ylim = c(0, my);
  } else {
    my = ylim[2];
  }
  if(is.null(yaxmax))
    yaxmax = floor(my);
  
  if(newplot){
    plot(
      x = NA, 
      y = NA, 
      ylim = ylim, 
      xlim = c(0, mx), 
      xaxs = "i", 
      yaxs = "i", 
      xlab = xlab,
      ylab = ylab,
      axes = FALSE);
    axistep = floor(mx/5);
    axis(1, seq(0, mx, axistep), lwd = lwd);
    axistep = floor(yaxmax/5);
    axis(2, seq(0, yaxmax, axistep), lwd = lwd);
    abline(a = 0, b = 1, col = col.band, lwd = lwd, lty =2);
    points(qq$xpvs, qq$ypvs, col = col, cex = cex, pch = 19);
    
    if( !is.null(ci.level) ){
      if( (ci.level>0)&(ci.level<1) ){
        quantiles = qbeta(
          p = rep(c(ci.level/2,1-ci.level/2), each=length(qq$xpvs)), 
          shape1 = qq$keep, 
          shape2 = qq$ntests - qq$keep + 1);
        quantiles = matrix(quantiles, ncol=2);
        
        lines( qq$xpvs, -log10(quantiles[,1]), col = col.band, lwd = lwd, lty =2);
        lines( qq$xpvs, -log10(quantiles[,2]), col = col.band, lwd = lwd, lty =2);
      }
    }
    if(makelegend){
      if( !is.null(ci.level) ){
        legend(
          "topleft", 
          legend = c(
            expression(paste(italic("Raw P"), " value")),
            expression(paste(lambda[GC],italic(" corrected P")," value")),
            sprintf("%.0f%% CI",100-ci.level*100)),
          lwd = c(0, 0, lwd), 
          pch = c(19, 19, NA_integer_), 
          lty = c(0, 0, 2), 
          col = c(col, "darkblue", col.band),
          box.col = "transparent",
          bg = "transparent");
      } else {
        legend(
          "topleft", 
          legend = c(
            expression(paste(italic("Raw P"), " value")),
            expression(paste(lambda[GC],italic(" corrected P")," value"))
          ),
          lwd = c(0, 0), 
          pch = c(19, 19), 
          lty = c(0, 0), 
          col = c(col, "darkblue"),
          box.col = "transparent",
          bg = "transparent");
      }
    }
    title(title);
  } else {
    points(qq$xpvs, qq$ypvs, col = "darkblue", cex = cex, pch = 19);
  }
  
  #if( !is.null(qq$lambda) ){
  #    lastr = sprintf("%.3f", qq$lambda);
  #    legend("bottom", legend = bquote(lambda == .(lastr)), bty = "n")
  #}
  return(invisible(qq));
}

# Prepare the compact summary of p-values for Manhattan plot
manhattanCache = function(
  pvalues,
  chr,
  pos,
  ismlog10 = FALSE,
  chrmargins = 5e6){
  # chr = locs[,1]; pos = locs[,2]; pvalues = mwas[,3]
  # z = getMWASandLocations(param)
  # chr = z$chr; pos = z$start; pvalues = z$`p-value`; 
  # ismlog10 = FALSE; chrmargins = 0;
  
  stopifnot( length(pvalues) == length(chr) );
  stopifnot( length(pvalues) == length(pos) );
  
  # Factorize chromosome
  if(is.double(chr))
    chr = as.integer(chr);
  if(is.character(chr))
    chr = factor(chr);
  if(is.integer(chr)) {
    levels(chr) = as.character(seq_len(tail(chr,1)));
    class(chr) = "factor";
  }
  
  # max of each chromosome
  poslist = split(pos, chr, drop = FALSE);
  poslist[vapply(poslist, length, 0)==0] = list(0);
  chrmax = vapply(poslist, max, 0) + 0;# + chrmargins;
  
  # chromosome starts on the plot
  names(chrmax) = NULL;
  offsets = c(0, cumsum(chrmax)) + chrmargins;
  names(offsets)[seq_along(poslist)] = levels(chr);
  
  # within plot coordinates
  x0 = offsets[unclass(chr)] + pos;
  if(ismlog10) {
    y0 = pvalues;
  } else {
    y0 = -log10(pvalues);
  }
  
  # Prune the data
  yfac = as.integer(y0*100)+1L;
  yorder = sort.list(yfac);
  levels(yfac) = as.character(seq_len(max(yfac)));
  class(yfac) = "factor";
  
  ygroup = split(seq_along(yfac), yfac);
  for( i in seq_along(ygroup)){ # i=1
    if( length(ygroup[[i]]) > 300 ){
      ygroup[[i]] = sample(ygroup[[i]], size = 300, replace = FALSE);
    }
  }
  # sum(vapply(ygroup, length, 0))
  keep = unlist(ygroup, use.names = FALSE);
  
  # Color code
  colindex = unclass(chr);
  
  # Chromosome names
  chrnames = gsub("chr", "", levels(chr));
  
  # Return minimum object;
  man = list(
    x = x0[keep],
    y = y0[keep],
    colindex = colindex[keep],
    offsets = offsets,
    chrnames = chrnames,
    chrmargins = chrmargins
  );
  class(man) = "manPlotInfo";
  return(man);
}

# Create Manhattan plot from prepared summary
manhattan = function(
  man,
  ylim = NULL,
  colorSet = c("steelblue4", "#2C82D1", "#4CB2D1"),
  yaxmax = NULL,
  significant = 1e-5,
  lwd = 3,
  cex = 1,
  title = ""){
  
  if( !methods::is(man, "manPlotInfo") )
    stop("The \"man\" parameter is not produced by manPlotPrepare().");
  
  # Axis ranges
  if(is.null(ylim)) {
    my = max(man$y) * 1.05;
    ylim = c(0,my);
  } else {
    my = ylim[2];
  }
  if(is.null(yaxmax))
    yaxmax = floor(my);
  
  # Plot frame
  plot(
    x = NA,
    y = NA, 
    xlim = c(0, tail(man$offsets,1)), 
    ylim = ylim, 
    xaxs = "i", 
    yaxs = "i",
    xlab = "Chromosome", 
    ylab = expression(
      paste("\u2013", " log"[10]*"(", italic("p"), ")")),
    axes = FALSE);
  axis(
    side = 1,
    at = man$offsets,
    labels = rep("", length(man$offsets)),
    lwd = lwd);
  axis(
    side = 1,
    at = (man$offsets[-1] + man$offsets[-length(man$offsets)])/2,
    labels = man$chrnames,
    tick = FALSE,
    lwd = lwd);
  axis(
    side = 2,
    at = seq(0, yaxmax, floor(yaxmax/5)),
    lwd = lwd);
  
  # plot points in palette color
  oldPal = palette(colorSet);
  points(
    x = man$x,
    y = man$y,
    pch = 16,
    col = ((man$colindex-1L) %% length(colorSet)) + 1L,
    cex = cex);
  abline(h=-log10(significant),lty=2,col='red',lwd=1)
  palette(oldPal);
  title(title);
}
```

# {.tabset .tabset-fade .tabset-pills}
## 1 MAF
```{r, maf,echo=TRUE}
fq=read.table(paste0(params$froot, ".frq"), as.is = T, header = T)
hist(fq$MAF, main="MAF", xlab="Minor allele frequency", xlim=c(0, 0.5), breaks = 50)
```
Minor allele frequency distribution of the sample.

## 2 Eigenanalysis
```{r, pca,echo=TRUE}
layout(matrix(1:2, 1, 2))
pcRun = 10
evalF=read.table(paste0(params$froot, ".eigenval"), as.is = T)
evalF=evalF[,1]
names(evalF) = c(1:pcRun)
barplot(evalF/params$sc, border = F, main="Eigenvalue",ylim = c(0,max(evalF/params$sc)*1.2),xlab = 'Eigenspace')
abline(h=1, lty=2, col="black")

pcF=read.table(paste0(params$froot, ".eigenvec"), as.is = T)
plot(main="eSpace 1 vs 2", pcF[,3], pcF[,4], xlab="eSpace 1", ylab="eSpace 2", bty='n', pch=16, cex=0.5, col=ifelse(pcF[,3]<0, "red", "blue"))
```
The distribution of the top-ranked eigenvalues and the projection of the samples in the first two eigenspaces.

## 3 GRM
```{r, grm,echo=TRUE}
layout(matrix(1:2, 1, 2))
Ne=params$ne
Me=params$me
hist(params$offDiag/params$sc, main="Pairwise relatedness ", xlab="Self-Relatedness", breaks = 50)
        
nn=params$nn
mm=params$mm
legend("topright", legend = c(paste0("ne=", format(Ne, digits=3, nsmall=2), ' [',nn, ']'), paste0("me=", format(Me, digits=3, nsmall=2), ' [',mm,']')), bty='n')

hist(params$Diag/params$sc, main="Diagonal relatedness", xlab="Relatedness score", breaks = 15)
```
Relatedness score is defined as the pairwise relatedness for any pair of individuals as measured over genome-wide markers. It is often employed for the estimation for additive genetic variance, see VanRaden ([$J Dairy Sci, 2008, 91:4414-4423$](https://www.sciencedirect.com/science/article/pii/S0022030208709901)) for more details. $n_e$ is the effective sample size. If the samples are related to each other much, $n_e$ would be smaller than the real sample size (in square brackets). $m_e$ is the effective number of markers. When markers are in linkage equilibrium, $m_e$=$m$, the number of markers in study (in square brackets). Of note, when the sample has experienced, recent, strong selection, me can be very small, say less than 0.01$m$; however, it can be of demographic factors possible.

## 4 Eigenvalue vs $\lambda_{GC}$
```{r, ev,echo=TRUE}
PC=params$espace
Evev=evalF
GC=params$GC

egc=matrix(c(Evev[1:PC]/params$sc, GC), PC, 2, byrow = F)
egc_table = cbind(as.character(seq(1, PC)),as.data.frame(format(egc,digits = 3)))
library(knitr)
kable(egc_table, align = 'c',col.names = c("Eigenspace","Eigenvalue", "Genomic inflation factor"))
rownames(egc)=seq(1, PC)
barplot(t(egc), beside = T, border = F, xlab="eSpace", ylim=c(0,max(egc)+2))
        abline(h=1, lty=2, lwd=2)
legend("topright", legend = c("Eigenvalue", expression(lambda[gc])), pch=15, col=c("black", "grey"), bty='n')

```
Eigenvalue follows a mixture distribution $\eta$$F_{st,s}$+(1-$\eta$)$F_{st,d}$, and $\lambda_{GC}$ is proportional to $F_{st,d}$. If eigenvalue is far larger than $\lambda_{GC}$, it indicates the presence of selection sweep of the sample.

## 5 EigenGWAS
Manhattan plot and Q-Q plot for EigenGWAS scanning on the chosen eigenvector. The p-value threshold, grey line in the Manhattan plot, is set at genome-wide control for type I error rate of 0.05 (Bonferroni correction). The grey points in the Q-Q plot are for the test statistics without technical correction for genome-wide drift, and the dark ones with technical correction for genome-wide drift.
```{r, eGWAS, results="asis",fig.align="center",echo=TRUE}
PC=params$espace
froot = params$froot

for(i in 1:PC) {
  EigenResName = paste0(tempdir(),'/EgE',i,'.png')
  QQPlotName = paste0(tempdir(),'/QQE',i,'.png')
  if(!file.exists(EigenResName)){
    EigenRes=read.table(paste0(froot, ".", i, ".assoc.linear"), as.is = T, header = T, 
                        colClasses=c("numeric","character","numeric","NULL","NULL","NULL","NULL","numeric","numeric"))
    EigenRes=EigenRes[which(!is.na(EigenRes$P)),]
    EigenRes$Praw=EigenRes$P
    gc=params$GC[i]
    EigenRes$P=pchisq((EigenRes$STAT)^2/gc, 1, lower.tail = F)

    EigenRes_sig = EigenRes[EigenRes$P<=0.05,]
    EigenRes_no_sig = EigenRes[EigenRes$P>0.05,]
    EigenRes_com = rbind(EigenRes_sig,EigenRes_no_sig[sample(1:nrow(EigenRes_no_sig),0.6*nrow(EigenRes_no_sig)),])
    
    man_cache = manhattanCache(pvalues = EigenRes_com$P,chr = as.character(EigenRes_com$CHR),pos = EigenRes_com$BP,ismlog10 = FALSE)
    png(filename = EigenResName, width = params$width,height = params$height)
    manhattan(man_cache,significant = 0.05/nrow(eg),cex = 0.4,colorSet = c("grey","darkblue"),title=paste0("ePC",i))
    dev.off()
    
    qq_cache_raw = qqPlotCache(EigenRes$Praw)
    qq_cache_gc = qqPlotCache(EigenRes$P)
    png(filename = QQPlotName,width = params$width,height = params$height)
    qqPlotQ(qq_cache_raw,ci.level = NULL, cex = 0.4,title=paste0("ePC",pcIdx))
    qqPlotQ(qq_cache_gc,ci.level = NULL,newplot = F, cex = 0.4)
    dev.off()
  }
  cat("\n<center>\n")
  cat(paste0("![](",EigenResName,")"),"\n")
  cat("\n</center>\n")
  cat("\n<center>\n")
  cat(paste0("![](",QQPlotName,")"),"\n")
  cat("\n</center>\n")
}
# When kable() is wrapped insiade other expression such as for loop, print(kable()) must be explicit
knitr::kable(params$hitDT,
             caption = "Top hits in each espace", 
             col.names = c("Espace", "CHR", "SNP", "BP", "P", "Praw"),
             row.names = FALSE,
             align = 'c')

```

## 6 Citation
[Chen, G.B. et al, EigenGWAS: finding loci under selection through genome-wide association studies of eigenvectors in structured populations, Heredity, 2016, 117:51-61.](https://www.nature.com/articles/hdy201625)

[Guo-An Qi et al, EigenGWAS: An online visualizing and interactive application for detecting genomic signatures of natural selection, Molecular Ecology Resources, 2021, 00:1-13.](https://onlinelibrary.wiley.com/doi/10.1111/1755-0998.13370)

## 7 Logs
```{r, logs,echo=FALSE}
nn=nrow(read.table(paste0(params$froot, ".fam"), as.is = T))
mm=nrow(read.table(paste0(params$froot, ".bim"), as.is = T))
popTp = ifelse(params$sc==1,"outbred","inbred")
cat(paste0("Input file: "),params$uploadfile)
cat(paste0("Population type: ",popTp))
cat(paste0("Sample size: ",nn))
cat(paste0("Markers: ",mm))
cat(paste0("Marker proportion for quick eigen-decomposition: ",params$proportion*100,"%"))
cat(paste0("Scanned eigen spaces: ",params$espace))
cat(paste0("Report generated at: ",Sys.time()," CHN"))
```
